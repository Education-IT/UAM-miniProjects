n = 92849481217896076206347850615207614211537760844551107956042590562350799670062048114835489606571504712967744342434269317448998135677589177717212065462911562760208661877159684467090151615171979099230684850612929030484358380075172864010962641033147651836768217092285905735443119459961765277546134269224943970247440416085252354729765008426878088808034296944141748615228109976822607290826092468745926323451868846367481806149087418833654282984043313677877137452289068448110320543953315257325853415969965403921924150771840515292713556777928922640976489021065657362856006364627605458969073715922640608656921337
a = 66156062224681942529358672540927506116289947292485944998652694752638246509280116706074103244995002274236847049082181320666917844119450567803817628126633272052726421973602704471624311698169966468601108310439129698456299289385001316500591093318212830915726981260239834413595812186441471584064984199270286905693990828316314374584984980255587790089932282496789756269343264827309341100389745416907094063552358190005970056241090373705957386296250496230863822570241944302406032504524452541395537495448400609696528119212841135172850397680823166922713870891783429860568838928993136748668201913872221788721527370
x = -24853558947863305270684636479915257398664521080165158047410628013180799813687504979506674591898879982463708356177917963716491150603376624835173070817502850374774720694124645978906361989248482666108875259751212140671750329333444747618716133855996963047261237482403264038854168146770756205241636437536733289844304581266494086655487691397332988581994942091457583838541074324223979401058777887791952860920802698025399537852041587509048984706900565899462969005537044052704708983476199631031332338813011838792192388577158399994326066372000568750505323098446742928865097540089202140071957272548072448367210530
y = 17708376726425209522865578611421158825016176134463626901548423788777016392866429261029426412702225428425277161665746231120415925378050897673808856584998480143242176076168659248592996736957794025595628242090082450849343669144349174333798958950014955707505195598365014680424282717710269023671919070848038408820472915624474882848782269444903390345500196747137199551894351450197459673223190534175831195451540996584925079431320208935625956463602589236850097209918224717897179198647675732662049391442362760955414530060954125503518307854763420365377628071022411672925083480421967267247255536849112030039440573
b = 67995922270032770935663214135292356812873239764385949908631962549169999856374543135328815014672624730504035986256351353732506985074212552882038994645408712385433941183035038488183789625923496433121809590861716889812608050741728116392246507177150688789506979609882641696588951313191009072304497831688210680403135834818758268074277317029545100226039354852684164776687035652598627889767314580953973462531066148342082268297045831324605298277142747778414168446752024395405611560477115626294521077156953565129731762194682115298387490405928353890471165922618914433990908824538403318897116443374568160289710807

# To implement the extended Euclid algorithm I used code example from a book titled:
# "Wprowadzanie do Kryptografii Johannes A. Buchmann PWN Warszawa 2006 str. 13"

def xeuclid(a,n):
    xs = [1,0] #ustalamy wartości początkowe współczynników
    ys = [0,1]

    while n!=0: # dopóki iloraz (dzielnik !=0)
        r = a % n #reszta dzielenia modulo z a%n
        q = a // n #liczba całkowita dzielenień   q * n + r
        a = n  # przesunięcie zmiennych aby wykorzystać je w następnej iteracji
        n = r # przesunięcie zmiennych aby wykorzystać je w następnej iteracji
        xx = xs[1] #W każdej iteracji aktualizujemy wartości w xs i ys, aby znaleźć nowe przybliżenia x i y
        yy = ys[1]
        xs[1] = xs[0] - q*xs[1] # od wyniku równania ( 1 ) odejmujemy równanie ( 2 ) wymnożone przez q
        ys[1] = ys[0] - q*ys[1]
        xs[0] = xx #Przypisujemy poprzednie wartości aby pracować na nich w następnej iteracji
        ys[0] = yy
        # print("-----")
        # print(f"xs[1] = {xs[0]} - {q}*{xs[1]}")
        # print(f"ys[1] = {ys[0]} - {q}*{ys[1]}")
        # print(f"xs[0] = {xx}")
        # print(f"ys[0] = {yy}")

    print(xs[0])
    return (a,xs[0],ys[0])

def zad1(a, n):
    nwd, result_X, result_Y = xeuclid(a, n)
    if nwd != 1: # jeśli nwd != 1 to znaczy że liczby nie są względnie pierwsze czyli nie można znaleźć liczby odwrotnej
        print(f'The inverse number doesn\'t exist because a and n are not relatively prime!')
        return
    else:
        return (result_X % n,result_X,result_Y) #zgodnie z wzorem x % n = liczba odwrotna

result = zad1(a,n)
print("\n#-- Example 1 --#")
print(f"Is the result an inverse number? {result[0] == b}")
print(f"Is x == result.x? {result[1] == x}")
print(f"Is y == result.y? {result[2] == y}\n\n")

# https://jgarnek.faculty.wmi.amu.edu.pl/files/2021krypto/modul1_przykladowe_dane.txt
##==========================================================
print("#-- Example 2 --#")
a = 3
n = 1073741819
b = 357913940
result = zad1(a,n)
print(f"Is the result an inverse number? {result[0] == b}\n\n")

##==========================================================
print("#-- Example 3 --#")
a = 100
n = 54321
b = 10321
result = zad1(a,n)
print(f"Is the result an inverse number? {result[0] == b}\n")

##==========================================================
print("#-- Example 4 --#")
a = 9
n = 64
b = 57
result = zad1(a,n)
print(f"Is the result an inverse number? {result[0] == b }\n")
